#!/usr/bin/env ruby
require 'cifrado'
require 'yaml'
require 'ruby-progressbar'

$0 = "cifrado #{ARGV.join(' ')}"

class CifradoCLI < Thor

  include Cifrado
  include Cifrado::Utils

  check_unknown_options!

  class_option :username
  class_option :password
  class_option :auth_url

  desc "list [CONTAINER]", "List containers and objects"
  option :insecure, :type => :boolean
  def list(container = nil)
    config = check_options options
    client = Cifrado::SwiftClient.new :username => config[:username], 
                                      :api_key  => config[:password],
                                      :auth_url => config[:auth_url],
                                      :connection_options => { :ssl_verify_peer => !options[:insecure] }
    client.service.directories.each { |d| puts d.key }
  end

  desc "container-add CONTAINER [DESCRIPTION]", "Create a container"
  option :insecure, :type => :boolean
  def container_add(container, description = '')
    config = check_options options
    client = Cifrado::SwiftClient.new :username => config[:username], 
                                      :api_key  => config[:password],
                                      :auth_url => config[:auth_url],
                                      :connection_options => { :ssl_verify_peer => !options[:insecure] }
    client.service.directories.create :key => container, 
                                      :description => description
  end

  desc "delete CONTAINER [OBJECT]", "Delete specific container or object"
  def delete(container, object = nil)
  end

  desc "cache-clean", "Empty Cifrado's cache directory"
  def clean_cache
    Log.info "Cleaning cache dir #{Config.instance.cache_dir}"
    Dir["#{Config.instance.cache_dir}/*.encrypted"].each { |f| File.delete f }
    Dir["#{Config.instance.cache_dir}/*-chunk-*"].each { |f| File.delete f }
    Dir["#{Config.instance.cache_dir}/*.md5"].each { |f| File.delete f }
  end

  desc "setup", "Initial Cifrado configuration"
  def setup
    check_options options
    Log.debug "Setup done"
  end

  desc "set-acl CONTAINER", 'Set an ACL on containers and objects'
  option :acl, :type => :string, :required => true
  option :insecure, :type => :boolean
  def set_acl(container, object = nil)
    config = check_options options
    client = Cifrado::SwiftClient.new :username => config[:username], 
                                      :api_key  => config[:password],
                                      :auth_url => config[:auth_url],
                                      :connection_options => { :ssl_verify_peer => !options[:insecure] }
    client.set_acl options[:acl], container
  end

  desc "upload CONTAINER FILE", "Upload a file"
  option :encrypt
  option :segments, :type => :numeric
  option :insecure, :type => :boolean
  option :strip_path, :type => :boolean
  option :no_progressbar,   :type => :boolean
  option :fast_progressbar, :type => :boolean
  def upload(container, file)

    unless File.exist?(file)
      Log.error "File '#{file}' does not exist"
      exit 1
    end

    config = check_options options
    begin 
      client = Cifrado::SwiftClient.new :username => config[:username], 
                                        :api_key  => config[:password],
                                        :auth_url => config[:auth_url],
                                        :connection_options => { :ssl_verify_peer => !options[:insecure] }


      ENV['CIFRADO_FAST_PROGRESSBAR'] = 'yes' if options[:fast_progressbar]

      tstart = Time.now
      if options[:segments]
        split_and_upload client, container, file, options
      else
        upload_single client, container, file, options
      end
      tend = Time.now
      Log.info "Time taken #{(tend - tstart).round} s."

    rescue Excon::Errors::Unauthorized => e
      Log.error set_color("Unauthorized.", :red, true)
      Log.error "Double check the username, password and auth_url."
    rescue Excon::Errors::SocketError => e
      if e.message =~ /Unable to verify certificate/
        Log.error "Unable to verify certificate. Try using --insecure."
      end
    end
  end

  private
  def check_options(options)
    config_file = File.join(ENV['HOME'], '.cifradorc')
    config = {}

    if File.exist?(config_file)
      begin
        Log.debug "Configuration file found: #{config_file}"
        Cifrado::Log.debug "Trying to read config file #{config_file}"
        config = YAML.load_file(config_file)
        Cifrado::Log.debug "Config #{config_file} read"
        original_config = config.dup
      rescue => e
        Cifrado::Log.error "Error loading config file"
        Cifrado::Log.error e.message
      end
    end

    config[:username] = options[:username] || config[:username] || ask('username:')
    if options[:password] or config[:password]
      config[:password] = options[:password] || config[:password]
    else
      system 'stty -echo -icanon'
      config[:password] = ask('password:')
      system 'stty echo icanon'
      puts
    end
    config[:auth_url] = options[:auth_url] || config[:auth_url] || ask('auth_url:')

    unless File.exist?(config_file)
      puts
      puts "Cifrado can save this settings in #{ENV['HOME']}/.cifradorc"
      puts "for later use."
      puts "The settings (password included) are saved unencrypted."
      puts
      if yes? "Do you want to save these settings?"
        File.open(config_file, 'w') do |f| 
          f.puts config.to_yaml
          f.chmod 0600
        end
        @settings_saved = true
      end
    end

    if original_config != config and !@settings_saved
      puts "username, password and/or auth_url changed"
      if yes? "Do you want to save the NEW settings?"
        File.open(config_file, 'w') { |f| f.puts config.to_yaml }
      end
    end

    config
  end

  def upload_single(client, container, object, options)
    fsize = File.size(object)
    fbasename = File.basename(object)
    Log.info "Uploading #{fbasename} (#{humanize_bytes(fsize)})"
    unless options[:no_progressbar]
      cb = progressbar_callback(1, 1)
    else
      cb = nil
    end
    config = Cifrado::Config.instance
    object_path = object
    object_path = File.basename(object) if options[:strip_path]
    if recipient = needs_encryption(options)
      cs = CryptoServices.new
      encrypted_file = File.join(config.cache_dir, fbasename) + ".encrypted"
      cs.encrypt object, encrypted_file, :recipient => recipient
      unless CryptoServices.encrypted?(encrypted_file)
        raise Exception.new "Could not encrypt file #{object}"
      end

      client.upload container, 
                    encrypted_file, 
                    :object_path => object_path,
                    :progress_callback => cb
      File.delete encrypted_file
    else
      client.upload container, 
                    object,
                    :object_path => object_path,
                    :progress_callback => cb
    end
  end

  def progressbar_callback(total = 0, count = 0)
    @progressbar_count = 0 
    @progressbar_finished = false
    Log.debug "Calling progressbar_callback"

    if ENV['CIFRADO_FAST_PROGRESSBAR']
      if total != 1
        title = "[#{count}/#{total}]"
      else
        title = ""
      end
      #Log.warn 'Using dummy progressbar callback'
      return Proc.new do |tbytes, bytes, nchunk| 
        @progressbar_count += bytes
        percentage = ((@progressbar_count*100.0/tbytes))
        if ((percentage % 10) < 0.1) and @progressbar_count <= tbytes
          print "\r"
          print "Progress (#{percentage.round}%) #{title}: "
          print '.' * (percentage/10).floor
        end
        if (@progressbar_count + bytes) >= tbytes and !@progressbar_finished
          @progressbar_finished = true
          percentage = 100
          print "\r"
          print "Progress (#{percentage.round}%) #{title}: "
          print '.' * (percentage/10).floor
          puts
        end
      end
    end

    title = (total == 1 ? 'Progress' : "Segment [#{count}/#{total}]")

    if RUBY_VERSION =~ /1\.8/
      # See https://github.com/jfelchner/ruby-progressbar/pull/25
      Log.warn "Progressbar performance is very poor under Ruby 1.8"
      Log.warn "If you are getting low throughtput when uploading"
      Log.warn  "upgrade to Ruby 1.9.X or use --no-progressbar"
    end
    @progressbar = ProgressBar.create :title => title, :total => 100
    cb = Proc.new do |total, bytes, nchunk| 
      @progressbar_count += bytes
      unless @progressbar_count > total
        increment = (bytes*100.0)/total
        percentage = ((@progressbar_count*100.0/total)).round
        @progressbar.title = "#{title} (#{percentage}%)"
        @progressbar.progress += increment 
        if (@progressbar_count + bytes) >= total
          @progressbar.finish
        end
      end
    end
  end

  def needs_encryption(options)
    return nil unless options[:encrypt]

    tokens = options[:encrypt].split(':')
    etype = tokens.first
    etarget = tokens[1..-1].join(':')
    if etype == 'a'
      recipient = etarget
    elsif etype == 's'
      raise NotImplemented.new
    else
      raise "Invalid encryption type #{etype}."
    end
    recipient
  end

  def split_and_upload(client, container, object, options)
    fbasename = File.basename(object)
    config = Cifrado::Config.instance
    if options[:encrypt]
      recipient = needs_encryption(options)
      Log.debug "Encrypting object #{object} for recipient #{recipient}"
      cs = CryptoServices.new
      encrypted_file = File.join(config.cache_dir, fbasename) + ".encrypted"
      cs.encrypt object, encrypted_file, :recipient => recipient
      unless !CryptoServices.encrypted?(encrypted_file)
        raise Exception.new "Could not encrypt file #{object}"
      end
    end
    
    if options[:encrypt]
      splitter = FileSplitter.new encrypted_file, options[:segments]
    else
      splitter = FileSplitter.new object, options[:segments]
    end
    Log.info "Segmenting file, #{options[:segments]} segments..."
    segments = splitter.split
    count = 0
    Log.info "Uploading #{fbasename} segments"
    segments.each do |segment|
      unless options[:no_progressbar]
        cb = progressbar_callback(segments.size, count+1)
      else
        cb = nil
      end
      count += 1
      segment_number = segment.split(splitter.chunk_suffix).last
      obj_path = object + splitter.chunk_suffix + segment_number
      obj_path = File.basename(obj_path) if options[:strip_path]
      Log.debug "Uploading segment #{obj_path} (#{File.size(segment)} bytes)..."
      client.upload container, 
                    segment, 
                    :object_path => obj_path,
                    :progress_callback => cb
    end
    
    Log.debug "Adding manifest #{object}"
    client.service.put_object_manifest container, object.gsub(/^\//, '')

    if options[:encrypt] and File.exist?(encrypted_file)
      Log.debug "Deleting encrypted file #{encrypted_file}"
      File.delete encrypted_file 
    end
  end

end

CifradoCLI.start ARGV, :shell => Thor::Shell::Color.new
